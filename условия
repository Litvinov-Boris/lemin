Objectives

•Ваша программа получит данные, описывающие муравьиную ферму, из стандартного вывода в следующем формате:
number_of_ants
the_rooms
the_links
• Муравьиная ферма определяется следующими ссылками:
##start
1 23 3
2 16 7
#comment
3 16 3
4 16 5
5 9 3
6 1 5
7 4 8
##end
0 9 5
0-4
0-6
1-3
4-3
5-2
3-5
#another comment
4-2
2-1
7-6
7-2
7-4
6-5
#another comment
• Что соответствует следующему представлению:
            _______________
           /              \
  ______[5]----[3]----[1] |
 /              |     /   |
[6]-----[0]----[4]   /    |
  \ _________/  |   /     |
   \ /         [2]/_______/
   [7]_________/
• Есть две части:
    ◦ комнатам, которые определяются: Имя coord_x coord_y
    ◦ Ссылки, которые определяются: name1-name2
    ◦ Все это разбито на комментарии, которые начинаются с #
• Строки, начинающиеся с ##, - это команды, изменяющие свойства строки, которая идет сразу после.
Например, ##start сигнализирует о входе в ферму муравьев, а ##end о выходе
• Любые несоответствующие или пустые строки автоматически останавливают чтение фермы муравьев, а также упорядоченную обработку полученных данных.
• Если данных для нормальной обработки недостаточно, вы должны отобразить ERROR

General Instructions
• Этот проект будет корректироваться только реальными людьми. Таким образом, вы можете свободно организовывать и называть свои файлы по своему усмотрению, хотя вам необходимо соблюдать некоторые требования, перечисленные ниже.
• Исполняемый файл должен иметь имя lem-in.
• Вы должны отправить Makefile. Этот Makefile должен компилировать проект и должен содержать обычные правила. Он может перекомпилировать программу только при необходимости.
• Если вы умны, вы будете использовать свою библиотеку для своего лемина. Также отправьте вашу папку libft, включая собственный Makefile, в корень вашего хранилища. Ваш Makefile должен будет скомпилировать библиотеку, а затем скомпилировать ваш проект
• Ваш проект должен быть написан на C в соответствии с нормой.
• Вы должны обрабатывать ошибки чувствительным образом. Ваша программа не может неожиданно завершить работу (ошибка сегментации, ошибка шины, двойное освобождение и т. Д.).
• Ваша программа не может иметь утечки памяти.
•Вам нужно будет отправить в корень вашей папки файл с именем author, содержащий два ваших имени пользователя, за которыми следует "\ n"
• В рамках вашей обязательной части вам разрешено использовать следующие функции:
    ◦ malloc, free (#include <stdlib.h>)
    ◦ read, write (#include <unistd.h>)
    ◦ strerror, perror (#include <string.h>
						#include <stdio.h>
						#include <errno.h>)
    ◦ exit (#include <unistd.h>
			#include <stdlib.h>)
•Вам разрешается использовать другие функции для выполнения бонусной части, если их использование оправдано во время вашей защиты.
•Вы можете задавать вопросы на форуме и Slack.

Mandatory part

• Цель этого проекта - найти самый быстрый способ перебросить муравьев по всей ферме.
• Самый быстрый способ означает решение с наименьшим количеством строк, с учетом формата вывода, запрошенного ниже.
• Очевидно, что есть некоторые основные ограничения. Чтобы быть первыми, муравьи должны будут выбрать кратчайший путь (и это не обязательно самый простой путь). Им также нужно будет избегать пробок и ходить по своим собратьям.
• В начале игры все муравьи находятся в комнате ## начало. Цель состоит в том, чтобы привести их в комнату ## как можно меньше поворотов. Каждая комната может содержать только одного муравья за раз
• Мы считаем, что все муравьи в комнате ##start в начале игры.
• На каждом ходу вы будете отображать только муравьев, которые двигались.
• На каждом ходу вы можете перемещать каждого муравья только один раз и через трубу (комната на приемном конце должна быть пустой).
• Вы должны отобразить результаты на стандартном выводе в следующем формате:
number_of_ants
the_rooms
the_links

Lx-y Lz-w Lr-o ...
x, z, r представляет номера муравьев (от 1 до number_of_ants), а y, w, o представляет имена комнат.
• В примере 2.1 не обязательно использовать все пути (вы можете сделать это, если в результате не будет больше строк, однако в некоторых случаях это будет неразумно) Однако вы ДОЛЖНЫ используйте несколько путей, если это необходимо (см. пример 2.2).
• И наконец, мы просим, чтобы ваш алгоритм мог использовать наилучшую комбинацию путей в соответствии с количеством муравьев в таких случаях, как приведенный ниже.
• Конечно, ваш алгоритм должен рендериться в разумные сроки, даже в случае с 4000 комнатами. 2 или 3 секунды - отлично, 9 секунд - посредственно, 15 секунд - это слишком много.
• Теперь было бы интересно узнать больше о типе операций, которые ученики Школы Волшебства могут проводить с таким компьютером. Все, что мы знаем, это то, что электричество сегодня намного надежнее.

Bonus part

Мы будем смотреть на ваши бонусы, если и только если ваша обязательная часть ОТЛИЧНО. Это означает, что вы должны выполнить обязательную часть, от начала до конца, ваш алгоритм эффективен в решении задачи субъекта, и ваше управление ошибками должно быть безупречным, даже в случае неправильного или неправильного использования. Если это не так, ваши бонусы будут полностью игнорироваться.
Найдите ниже несколько идей интересных бонусов, которые вы могли бы создать. Некоторые могут даже быть полезными. Вы, конечно, можете изобрести свой собственный, который затем будет оценен вашими корректорами по своему вкусу.
• В качестве бонуса, почему бы не кодировать визуализатор фермы муравьев?
    ◦ Ither Либо в двух измерениях, если смотреть сверху. Или еще лучше с точки зрения муравья в коридорах фермы в 3D.
    ◦ Чтобы использовать его, мы могли бы написать: ./lem-in <ant_farm_map.txt | ./visu-hex
    ◦ Обратите внимание, что поскольку команды и комментарии также отображаются в стандартном выводе, можно передавать определенные команды визуализатору (например, различные цвета или уровни).
    ◦ Вы должны были заметить, что координаты комнаты будут полезны только здесь.
